// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Tron.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// AccountId, (name, address) use name, (null, address) use address, (name, null) use name,
public struct TW_Tron_Proto_AccountId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Data = SwiftProtobuf.Internal.emptyData

  public var address: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_Tron_Proto_authority {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: TW_Tron_Proto_AccountId {
    get {return _storage._account ?? TW_Tron_Proto_AccountId()}
    set {_uniqueStorage()._account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return _storage._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {_uniqueStorage()._account = nil}

  public var permissionName: Data {
    get {return _storage._permissionName}
    set {_uniqueStorage()._permissionName = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TW_Tron_Proto_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawData: TW_Tron_Proto_Transaction.raw {
    get {return _storage._rawData ?? TW_Tron_Proto_Transaction.raw()}
    set {_uniqueStorage()._rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  public var hasRawData: Bool {return _storage._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  public mutating func clearRawData() {_uniqueStorage()._rawData = nil}

  /// only support size = 1,  repeated list here for muti-sig extension
  public var signature: [Data] {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  public var ret: [TW_Tron_Proto_Transaction.Result] {
    get {return _storage._ret}
    set {_uniqueStorage()._ret = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Contract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: TW_Tron_Proto_Transaction.Contract.ContractType {
      get {return _storage._type}
      set {_uniqueStorage()._type = newValue}
    }

    public var parameter: SwiftProtobuf.Google_Protobuf_Any {
      get {return _storage._parameter ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_uniqueStorage()._parameter = newValue}
    }
    /// Returns true if `parameter` has been explicitly set.
    public var hasParameter: Bool {return _storage._parameter != nil}
    /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
    public mutating func clearParameter() {_uniqueStorage()._parameter = nil}

    public var provider: Data {
      get {return _storage._provider}
      set {_uniqueStorage()._provider = newValue}
    }

    public var contractName: Data {
      get {return _storage._contractName}
      set {_uniqueStorage()._contractName = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ContractType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case accountCreateContract // = 0
      case transferContract // = 1
      case transferAssetContract // = 2
      case voteAssetContract // = 3
      case voteWitnessContract // = 4
      case witnessCreateContract // = 5
      case assetIssueContract // = 6
      case witnessUpdateContract // = 8
      case participateAssetIssueContract // = 9
      case accountUpdateContract // = 10
      case freezeBalanceContract // = 11
      case unfreezeBalanceContract // = 12
      case withdrawBalanceContract // = 13
      case unfreezeAssetContract // = 14
      case updateAssetContract // = 15
      case proposalCreateContract // = 16
      case proposalApproveContract // = 17
      case proposalDeleteContract // = 18
      case setAccountIDContract // = 19
      case customContract // = 20

      /// BuyStorageContract = 21;
      /// BuyStorageBytesContract = 22;
      /// SellStorageContract = 23;
      case createSmartContract // = 30
      case triggerSmartContract // = 31
      case getContract // = 32
      case updateSettingContract // = 33
      case exchangeCreateContract // = 41
      case exchangeInjectContract // = 42
      case exchangeWithdrawContract // = 43
      case exchangeTransactionContract // = 44
      case UNRECOGNIZED(Int)

      public init() {
        self = .accountCreateContract
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .accountCreateContract
        case 1: self = .transferContract
        case 2: self = .transferAssetContract
        case 3: self = .voteAssetContract
        case 4: self = .voteWitnessContract
        case 5: self = .witnessCreateContract
        case 6: self = .assetIssueContract
        case 8: self = .witnessUpdateContract
        case 9: self = .participateAssetIssueContract
        case 10: self = .accountUpdateContract
        case 11: self = .freezeBalanceContract
        case 12: self = .unfreezeBalanceContract
        case 13: self = .withdrawBalanceContract
        case 14: self = .unfreezeAssetContract
        case 15: self = .updateAssetContract
        case 16: self = .proposalCreateContract
        case 17: self = .proposalApproveContract
        case 18: self = .proposalDeleteContract
        case 19: self = .setAccountIDContract
        case 20: self = .customContract
        case 30: self = .createSmartContract
        case 31: self = .triggerSmartContract
        case 32: self = .getContract
        case 33: self = .updateSettingContract
        case 41: self = .exchangeCreateContract
        case 42: self = .exchangeInjectContract
        case 43: self = .exchangeWithdrawContract
        case 44: self = .exchangeTransactionContract
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .accountCreateContract: return 0
        case .transferContract: return 1
        case .transferAssetContract: return 2
        case .voteAssetContract: return 3
        case .voteWitnessContract: return 4
        case .witnessCreateContract: return 5
        case .assetIssueContract: return 6
        case .witnessUpdateContract: return 8
        case .participateAssetIssueContract: return 9
        case .accountUpdateContract: return 10
        case .freezeBalanceContract: return 11
        case .unfreezeBalanceContract: return 12
        case .withdrawBalanceContract: return 13
        case .unfreezeAssetContract: return 14
        case .updateAssetContract: return 15
        case .proposalCreateContract: return 16
        case .proposalApproveContract: return 17
        case .proposalDeleteContract: return 18
        case .setAccountIDContract: return 19
        case .customContract: return 20
        case .createSmartContract: return 30
        case .triggerSmartContract: return 31
        case .getContract: return 32
        case .updateSettingContract: return 33
        case .exchangeCreateContract: return 41
        case .exchangeInjectContract: return 42
        case .exchangeWithdrawContract: return 43
        case .exchangeTransactionContract: return 44
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var fee: Int64 = 0

    public var ret: TW_Tron_Proto_Transaction.Result.code = .sucess

    public var contractRet: TW_Tron_Proto_Transaction.Result.contractResult = .default

    public var withdrawAmount: Int64 = 0

    public var unfreezeAmount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum code: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case sucess // = 0
      case failed // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .sucess
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .sucess
        case 1: self = .failed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .sucess: return 0
        case .failed: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public enum contractResult: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case `default` // = 0
      case success // = 1
      case revert // = 2
      case badJumpDestination // = 3
      case outOfMemory // = 4
      case precompiledContract // = 5
      case stackTooSmall // = 6
      case stackTooLarge // = 7
      case illegalOperation // = 8
      case stackOverflow // = 9
      case outOfEnergy // = 10
      case outOfTime // = 11
      case jvmStackOverFlow // = 12
      case unknown // = 13
      case UNRECOGNIZED(Int)

      public init() {
        self = .default
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .default
        case 1: self = .success
        case 2: self = .revert
        case 3: self = .badJumpDestination
        case 4: self = .outOfMemory
        case 5: self = .precompiledContract
        case 6: self = .stackTooSmall
        case 7: self = .stackTooLarge
        case 8: self = .illegalOperation
        case 9: self = .stackOverflow
        case 10: self = .outOfEnergy
        case 11: self = .outOfTime
        case 12: self = .jvmStackOverFlow
        case 13: self = .unknown
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .default: return 0
        case .success: return 1
        case .revert: return 2
        case .badJumpDestination: return 3
        case .outOfMemory: return 4
        case .precompiledContract: return 5
        case .stackTooSmall: return 6
        case .stackTooLarge: return 7
        case .illegalOperation: return 8
        case .stackOverflow: return 9
        case .outOfEnergy: return 10
        case .outOfTime: return 11
        case .jvmStackOverFlow: return 12
        case .unknown: return 13
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var refBlockBytes: Data = SwiftProtobuf.Internal.emptyData

    public var refBlockNum: Int64 = 0

    public var refBlockHash: Data = SwiftProtobuf.Internal.emptyData

    public var expiration: Int64 = 0

    public var auths: [TW_Tron_Proto_authority] = []

    /// data not used
    public var data: Data = SwiftProtobuf.Internal.emptyData

    ///only support size = 1,  repeated list here for extension
    public var contract: [TW_Tron_Proto_Transaction.Contract] = []

    /// scripts not used
    public var scripts: Data = SwiftProtobuf.Internal.emptyData

    public var timestamp: Int64 = 0

    public var feeLimit: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TW_Tron_Proto_BlockHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawData: TW_Tron_Proto_BlockHeader.raw {
    get {return _storage._rawData ?? TW_Tron_Proto_BlockHeader.raw()}
    set {_uniqueStorage()._rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  public var hasRawData: Bool {return _storage._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  public mutating func clearRawData() {_uniqueStorage()._rawData = nil}

  public var witnessSignature: Data {
    get {return _storage._witnessSignature}
    set {_uniqueStorage()._witnessSignature = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestamp: Int64 = 0

    public var txTrieRoot: Data = SwiftProtobuf.Internal.emptyData

    public var parentHash: Data = SwiftProtobuf.Internal.emptyData

    ///bytes nonce = 5;
    ///bytes difficulty = 6;
    public var number: Int64 = 0

    public var witnessID: Int64 = 0

    public var witnessAddress: Data = SwiftProtobuf.Internal.emptyData

    public var version: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct TW_Tron_Proto_TransferContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  public var toAddress: Data = SwiftProtobuf.Internal.emptyData

  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct TW_Tron_Proto_TransferAssetContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var assetName: Data = SwiftProtobuf.Internal.emptyData

  public var ownerAddress: Data = SwiftProtobuf.Internal.emptyData

  public var toAddress: Data = SwiftProtobuf.Internal.emptyData

  public var amount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.Tron.Proto"

extension TW_Tron_Proto_AccountId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.name)
      case 2: try decoder.decodeSingularBytesField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Tron_Proto_AccountId, rhs: TW_Tron_Proto_AccountId) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Tron_Proto_authority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".authority"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "permission_name"),
  ]

  fileprivate class _StorageClass {
    var _account: TW_Tron_Proto_AccountId? = nil
    var _permissionName: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _account = source._account
      _permissionName = source._permissionName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._account)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._permissionName)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._account {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._permissionName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._permissionName, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Tron_Proto_authority, rhs: TW_Tron_Proto_authority) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._account != rhs_storage._account {return false}
        if _storage._permissionName != rhs_storage._permissionName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Tron_Proto_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .same(proto: "signature"),
    5: .same(proto: "ret"),
  ]

  fileprivate class _StorageClass {
    var _rawData: TW_Tron_Proto_Transaction.raw? = nil
    var _signature: [Data] = []
    var _ret: [TW_Tron_Proto_Transaction.Result] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rawData = source._rawData
      _signature = source._signature
      _ret = source._ret
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._rawData)
        case 2: try decoder.decodeRepeatedBytesField(value: &_storage._signature)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._ret)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._rawData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._signature, fieldNumber: 2)
      }
      if !_storage._ret.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ret, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Tron_Proto_Transaction, rhs: TW_Tron_Proto_Transaction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rawData != rhs_storage._rawData {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._ret != rhs_storage._ret {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Tron_Proto_Transaction.Contract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_Tron_Proto_Transaction.protoMessageName + ".Contract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameter"),
    3: .same(proto: "provider"),
    4: .same(proto: "ContractName"),
  ]

  fileprivate class _StorageClass {
    var _type: TW_Tron_Proto_Transaction.Contract.ContractType = .accountCreateContract
    var _parameter: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _provider: Data = SwiftProtobuf.Internal.emptyData
    var _contractName: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _parameter = source._parameter
      _provider = source._provider
      _contractName = source._contractName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._parameter)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._provider)
        case 4: try decoder.decodeSingularBytesField(value: &_storage._contractName)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type != .accountCreateContract {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if let v = _storage._parameter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._provider.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._provider, fieldNumber: 3)
      }
      if !_storage._contractName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._contractName, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Tron_Proto_Transaction.Contract, rhs: TW_Tron_Proto_Transaction.Contract) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._parameter != rhs_storage._parameter {return false}
        if _storage._provider != rhs_storage._provider {return false}
        if _storage._contractName != rhs_storage._contractName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Tron_Proto_Transaction.Contract.ContractType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AccountCreateContract"),
    1: .same(proto: "TransferContract"),
    2: .same(proto: "TransferAssetContract"),
    3: .same(proto: "VoteAssetContract"),
    4: .same(proto: "VoteWitnessContract"),
    5: .same(proto: "WitnessCreateContract"),
    6: .same(proto: "AssetIssueContract"),
    8: .same(proto: "WitnessUpdateContract"),
    9: .same(proto: "ParticipateAssetIssueContract"),
    10: .same(proto: "AccountUpdateContract"),
    11: .same(proto: "FreezeBalanceContract"),
    12: .same(proto: "UnfreezeBalanceContract"),
    13: .same(proto: "WithdrawBalanceContract"),
    14: .same(proto: "UnfreezeAssetContract"),
    15: .same(proto: "UpdateAssetContract"),
    16: .same(proto: "ProposalCreateContract"),
    17: .same(proto: "ProposalApproveContract"),
    18: .same(proto: "ProposalDeleteContract"),
    19: .same(proto: "SetAccountIdContract"),
    20: .same(proto: "CustomContract"),
    30: .same(proto: "CreateSmartContract"),
    31: .same(proto: "TriggerSmartContract"),
    32: .same(proto: "GetContract"),
    33: .same(proto: "UpdateSettingContract"),
    41: .same(proto: "ExchangeCreateContract"),
    42: .same(proto: "ExchangeInjectContract"),
    43: .same(proto: "ExchangeWithdrawContract"),
    44: .same(proto: "ExchangeTransactionContract"),
  ]
}

extension TW_Tron_Proto_Transaction.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_Tron_Proto_Transaction.protoMessageName + ".Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fee"),
    2: .same(proto: "ret"),
    3: .same(proto: "contractRet"),
    15: .standard(proto: "withdraw_amount"),
    16: .standard(proto: "unfreeze_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.fee)
      case 2: try decoder.decodeSingularEnumField(value: &self.ret)
      case 3: try decoder.decodeSingularEnumField(value: &self.contractRet)
      case 15: try decoder.decodeSingularInt64Field(value: &self.withdrawAmount)
      case 16: try decoder.decodeSingularInt64Field(value: &self.unfreezeAmount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 1)
    }
    if self.ret != .sucess {
      try visitor.visitSingularEnumField(value: self.ret, fieldNumber: 2)
    }
    if self.contractRet != .default {
      try visitor.visitSingularEnumField(value: self.contractRet, fieldNumber: 3)
    }
    if self.withdrawAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.withdrawAmount, fieldNumber: 15)
    }
    if self.unfreezeAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.unfreezeAmount, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Tron_Proto_Transaction.Result, rhs: TW_Tron_Proto_Transaction.Result) -> Bool {
    if lhs.fee != rhs.fee {return false}
    if lhs.ret != rhs.ret {return false}
    if lhs.contractRet != rhs.contractRet {return false}
    if lhs.withdrawAmount != rhs.withdrawAmount {return false}
    if lhs.unfreezeAmount != rhs.unfreezeAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Tron_Proto_Transaction.Result.code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCESS"),
    1: .same(proto: "FAILED"),
  ]
}

extension TW_Tron_Proto_Transaction.Result.contractResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "REVERT"),
    3: .same(proto: "BAD_JUMP_DESTINATION"),
    4: .same(proto: "OUT_OF_MEMORY"),
    5: .same(proto: "PRECOMPILED_CONTRACT"),
    6: .same(proto: "STACK_TOO_SMALL"),
    7: .same(proto: "STACK_TOO_LARGE"),
    8: .same(proto: "ILLEGAL_OPERATION"),
    9: .same(proto: "STACK_OVERFLOW"),
    10: .same(proto: "OUT_OF_ENERGY"),
    11: .same(proto: "OUT_OF_TIME"),
    12: .same(proto: "JVM_STACK_OVER_FLOW"),
    13: .same(proto: "UNKNOWN"),
  ]
}

extension TW_Tron_Proto_Transaction.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_Tron_Proto_Transaction.protoMessageName + ".raw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ref_block_bytes"),
    3: .standard(proto: "ref_block_num"),
    4: .standard(proto: "ref_block_hash"),
    8: .same(proto: "expiration"),
    9: .same(proto: "auths"),
    10: .same(proto: "data"),
    11: .same(proto: "contract"),
    12: .same(proto: "scripts"),
    14: .same(proto: "timestamp"),
    18: .standard(proto: "fee_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.refBlockBytes)
      case 3: try decoder.decodeSingularInt64Field(value: &self.refBlockNum)
      case 4: try decoder.decodeSingularBytesField(value: &self.refBlockHash)
      case 8: try decoder.decodeSingularInt64Field(value: &self.expiration)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.auths)
      case 10: try decoder.decodeSingularBytesField(value: &self.data)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.contract)
      case 12: try decoder.decodeSingularBytesField(value: &self.scripts)
      case 14: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 18: try decoder.decodeSingularInt64Field(value: &self.feeLimit)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refBlockBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.refBlockBytes, fieldNumber: 1)
    }
    if self.refBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.refBlockNum, fieldNumber: 3)
    }
    if !self.refBlockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.refBlockHash, fieldNumber: 4)
    }
    if self.expiration != 0 {
      try visitor.visitSingularInt64Field(value: self.expiration, fieldNumber: 8)
    }
    if !self.auths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auths, fieldNumber: 9)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 10)
    }
    if !self.contract.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contract, fieldNumber: 11)
    }
    if !self.scripts.isEmpty {
      try visitor.visitSingularBytesField(value: self.scripts, fieldNumber: 12)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 14)
    }
    if self.feeLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.feeLimit, fieldNumber: 18)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Tron_Proto_Transaction.raw, rhs: TW_Tron_Proto_Transaction.raw) -> Bool {
    if lhs.refBlockBytes != rhs.refBlockBytes {return false}
    if lhs.refBlockNum != rhs.refBlockNum {return false}
    if lhs.refBlockHash != rhs.refBlockHash {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.auths != rhs.auths {return false}
    if lhs.data != rhs.data {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.scripts != rhs.scripts {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.feeLimit != rhs.feeLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Tron_Proto_BlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .standard(proto: "witness_signature"),
  ]

  fileprivate class _StorageClass {
    var _rawData: TW_Tron_Proto_BlockHeader.raw? = nil
    var _witnessSignature: Data = SwiftProtobuf.Internal.emptyData

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rawData = source._rawData
      _witnessSignature = source._witnessSignature
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._rawData)
        case 2: try decoder.decodeSingularBytesField(value: &_storage._witnessSignature)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._rawData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._witnessSignature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._witnessSignature, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Tron_Proto_BlockHeader, rhs: TW_Tron_Proto_BlockHeader) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rawData != rhs_storage._rawData {return false}
        if _storage._witnessSignature != rhs_storage._witnessSignature {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Tron_Proto_BlockHeader.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TW_Tron_Proto_BlockHeader.protoMessageName + ".raw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "txTrieRoot"),
    3: .same(proto: "parentHash"),
    7: .same(proto: "number"),
    8: .standard(proto: "witness_id"),
    9: .standard(proto: "witness_address"),
    10: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 2: try decoder.decodeSingularBytesField(value: &self.txTrieRoot)
      case 3: try decoder.decodeSingularBytesField(value: &self.parentHash)
      case 7: try decoder.decodeSingularInt64Field(value: &self.number)
      case 8: try decoder.decodeSingularInt64Field(value: &self.witnessID)
      case 9: try decoder.decodeSingularBytesField(value: &self.witnessAddress)
      case 10: try decoder.decodeSingularInt32Field(value: &self.version)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.txTrieRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.txTrieRoot, fieldNumber: 2)
    }
    if !self.parentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.parentHash, fieldNumber: 3)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 7)
    }
    if self.witnessID != 0 {
      try visitor.visitSingularInt64Field(value: self.witnessID, fieldNumber: 8)
    }
    if !self.witnessAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.witnessAddress, fieldNumber: 9)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Tron_Proto_BlockHeader.raw, rhs: TW_Tron_Proto_BlockHeader.raw) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.txTrieRoot != rhs.txTrieRoot {return false}
    if lhs.parentHash != rhs.parentHash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.witnessID != rhs.witnessID {return false}
    if lhs.witnessAddress != rhs.witnessAddress {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Tron_Proto_TransferContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferContract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "owner_address"),
    2: .standard(proto: "to_address"),
    3: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 2: try decoder.decodeSingularBytesField(value: &self.toAddress)
      case 3: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 1)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.toAddress, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Tron_Proto_TransferContract, rhs: TW_Tron_Proto_TransferContract) -> Bool {
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_Tron_Proto_TransferAssetContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferAssetContract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "asset_name"),
    2: .standard(proto: "owner_address"),
    3: .standard(proto: "to_address"),
    4: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.assetName)
      case 2: try decoder.decodeSingularBytesField(value: &self.ownerAddress)
      case 3: try decoder.decodeSingularBytesField(value: &self.toAddress)
      case 4: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assetName.isEmpty {
      try visitor.visitSingularBytesField(value: self.assetName, fieldNumber: 1)
    }
    if !self.ownerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.ownerAddress, fieldNumber: 2)
    }
    if !self.toAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.toAddress, fieldNumber: 3)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_Tron_Proto_TransferAssetContract, rhs: TW_Tron_Proto_TransferAssetContract) -> Bool {
    if lhs.assetName != rhs.assetName {return false}
    if lhs.ownerAddress != rhs.ownerAddress {return false}
    if lhs.toAddress != rhs.toAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
