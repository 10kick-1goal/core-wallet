// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TronInternal.proto

#ifndef PROTOBUF_INCLUDED_TronInternal_2eproto
#define PROTOBUF_INCLUDED_TronInternal_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TronInternal_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_TronInternal_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_TronInternal_2eproto();
namespace protocol {
class BlockHeader;
class BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class BlockHeader_raw;
class BlockHeader_rawDefaultTypeInternal;
extern BlockHeader_rawDefaultTypeInternal _BlockHeader_raw_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class Transaction_Contract;
class Transaction_ContractDefaultTypeInternal;
extern Transaction_ContractDefaultTypeInternal _Transaction_Contract_default_instance_;
class Transaction_raw;
class Transaction_rawDefaultTypeInternal;
extern Transaction_rawDefaultTypeInternal _Transaction_raw_default_instance_;
class TransferAssetContract;
class TransferAssetContractDefaultTypeInternal;
extern TransferAssetContractDefaultTypeInternal _TransferAssetContract_default_instance_;
class TransferContract;
class TransferContractDefaultTypeInternal;
extern TransferContractDefaultTypeInternal _TransferContract_default_instance_;
}  // namespace protocol
namespace google {
namespace protobuf {
template<> ::protocol::BlockHeader* Arena::CreateMaybeMessage<::protocol::BlockHeader>(Arena*);
template<> ::protocol::BlockHeader_raw* Arena::CreateMaybeMessage<::protocol::BlockHeader_raw>(Arena*);
template<> ::protocol::Transaction* Arena::CreateMaybeMessage<::protocol::Transaction>(Arena*);
template<> ::protocol::Transaction_Contract* Arena::CreateMaybeMessage<::protocol::Transaction_Contract>(Arena*);
template<> ::protocol::Transaction_raw* Arena::CreateMaybeMessage<::protocol::Transaction_raw>(Arena*);
template<> ::protocol::TransferAssetContract* Arena::CreateMaybeMessage<::protocol::TransferAssetContract>(Arena*);
template<> ::protocol::TransferContract* Arena::CreateMaybeMessage<::protocol::TransferContract>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace protocol {

enum Transaction_Contract_ContractType {
  Transaction_Contract_ContractType_AccountCreateContract = 0,
  Transaction_Contract_ContractType_TransferContract = 1,
  Transaction_Contract_ContractType_TransferAssetContract = 2,
  Transaction_Contract_ContractType_Transaction_Contract_ContractType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Transaction_Contract_ContractType_Transaction_Contract_ContractType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Transaction_Contract_ContractType_IsValid(int value);
const Transaction_Contract_ContractType Transaction_Contract_ContractType_ContractType_MIN = Transaction_Contract_ContractType_AccountCreateContract;
const Transaction_Contract_ContractType Transaction_Contract_ContractType_ContractType_MAX = Transaction_Contract_ContractType_TransferAssetContract;
const int Transaction_Contract_ContractType_ContractType_ARRAYSIZE = Transaction_Contract_ContractType_ContractType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transaction_Contract_ContractType_descriptor();
inline const ::std::string& Transaction_Contract_ContractType_Name(Transaction_Contract_ContractType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transaction_Contract_ContractType_descriptor(), value);
}
inline bool Transaction_Contract_ContractType_Parse(
    const ::std::string& name, Transaction_Contract_ContractType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transaction_Contract_ContractType>(
    Transaction_Contract_ContractType_descriptor(), name, value);
}
// ===================================================================

class Transaction_Contract final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.Contract) */ {
 public:
  Transaction_Contract();
  virtual ~Transaction_Contract();

  Transaction_Contract(const Transaction_Contract& from);

  inline Transaction_Contract& operator=(const Transaction_Contract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction_Contract(Transaction_Contract&& from) noexcept
    : Transaction_Contract() {
    *this = ::std::move(from);
  }

  inline Transaction_Contract& operator=(Transaction_Contract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Transaction_Contract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction_Contract* internal_default_instance() {
    return reinterpret_cast<const Transaction_Contract*>(
               &_Transaction_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Transaction_Contract* other);
  friend void swap(Transaction_Contract& a, Transaction_Contract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction_Contract* New() const final {
    return CreateMaybeMessage<Transaction_Contract>(nullptr);
  }

  Transaction_Contract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction_Contract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction_Contract& from);
  void MergeFrom(const Transaction_Contract& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction_Contract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Transaction_Contract_ContractType ContractType;
  static const ContractType AccountCreateContract =
    Transaction_Contract_ContractType_AccountCreateContract;
  static const ContractType TransferContract =
    Transaction_Contract_ContractType_TransferContract;
  static const ContractType TransferAssetContract =
    Transaction_Contract_ContractType_TransferAssetContract;
  static inline bool ContractType_IsValid(int value) {
    return Transaction_Contract_ContractType_IsValid(value);
  }
  static const ContractType ContractType_MIN =
    Transaction_Contract_ContractType_ContractType_MIN;
  static const ContractType ContractType_MAX =
    Transaction_Contract_ContractType_ContractType_MAX;
  static const int ContractType_ARRAYSIZE =
    Transaction_Contract_ContractType_ContractType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ContractType_descriptor() {
    return Transaction_Contract_ContractType_descriptor();
  }
  static inline const ::std::string& ContractType_Name(ContractType value) {
    return Transaction_Contract_ContractType_Name(value);
  }
  static inline bool ContractType_Parse(const ::std::string& name,
      ContractType* value) {
    return Transaction_Contract_ContractType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes provider = 3;
  void clear_provider();
  static const int kProviderFieldNumber = 3;
  const ::std::string& provider() const;
  void set_provider(const ::std::string& value);
  #if LANG_CXX11
  void set_provider(::std::string&& value);
  #endif
  void set_provider(const char* value);
  void set_provider(const void* value, size_t size);
  ::std::string* mutable_provider();
  ::std::string* release_provider();
  void set_allocated_provider(::std::string* provider);

  // .google.protobuf.Any parameter = 2;
  bool has_parameter() const;
  void clear_parameter();
  static const int kParameterFieldNumber = 2;
  const ::google::protobuf::Any& parameter() const;
  ::google::protobuf::Any* release_parameter();
  ::google::protobuf::Any* mutable_parameter();
  void set_allocated_parameter(::google::protobuf::Any* parameter);

  // .protocol.Transaction.Contract.ContractType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protocol::Transaction_Contract_ContractType type() const;
  void set_type(::protocol::Transaction_Contract_ContractType value);

  // @@protoc_insertion_point(class_scope:protocol.Transaction.Contract)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr provider_;
  ::google::protobuf::Any* parameter_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class Transaction_raw final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction.raw) */ {
 public:
  Transaction_raw();
  virtual ~Transaction_raw();

  Transaction_raw(const Transaction_raw& from);

  inline Transaction_raw& operator=(const Transaction_raw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction_raw(Transaction_raw&& from) noexcept
    : Transaction_raw() {
    *this = ::std::move(from);
  }

  inline Transaction_raw& operator=(Transaction_raw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Transaction_raw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction_raw* internal_default_instance() {
    return reinterpret_cast<const Transaction_raw*>(
               &_Transaction_raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Transaction_raw* other);
  friend void swap(Transaction_raw& a, Transaction_raw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction_raw* New() const final {
    return CreateMaybeMessage<Transaction_raw>(nullptr);
  }

  Transaction_raw* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction_raw>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction_raw& from);
  void MergeFrom(const Transaction_raw& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction_raw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Transaction.Contract contract = 11;
  int contract_size() const;
  void clear_contract();
  static const int kContractFieldNumber = 11;
  ::protocol::Transaction_Contract* mutable_contract(int index);
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >*
      mutable_contract();
  const ::protocol::Transaction_Contract& contract(int index) const;
  ::protocol::Transaction_Contract* add_contract();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >&
      contract() const;

  // bytes ref_block_bytes = 1;
  void clear_ref_block_bytes();
  static const int kRefBlockBytesFieldNumber = 1;
  const ::std::string& ref_block_bytes() const;
  void set_ref_block_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_block_bytes(::std::string&& value);
  #endif
  void set_ref_block_bytes(const char* value);
  void set_ref_block_bytes(const void* value, size_t size);
  ::std::string* mutable_ref_block_bytes();
  ::std::string* release_ref_block_bytes();
  void set_allocated_ref_block_bytes(::std::string* ref_block_bytes);

  // bytes ref_block_hash = 4;
  void clear_ref_block_hash();
  static const int kRefBlockHashFieldNumber = 4;
  const ::std::string& ref_block_hash() const;
  void set_ref_block_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_ref_block_hash(::std::string&& value);
  #endif
  void set_ref_block_hash(const char* value);
  void set_ref_block_hash(const void* value, size_t size);
  ::std::string* mutable_ref_block_hash();
  ::std::string* release_ref_block_hash();
  void set_allocated_ref_block_hash(::std::string* ref_block_hash);

  // int64 ref_block_num = 3;
  void clear_ref_block_num();
  static const int kRefBlockNumFieldNumber = 3;
  ::google::protobuf::int64 ref_block_num() const;
  void set_ref_block_num(::google::protobuf::int64 value);

  // int64 expiration = 8;
  void clear_expiration();
  static const int kExpirationFieldNumber = 8;
  ::google::protobuf::int64 expiration() const;
  void set_expiration(::google::protobuf::int64 value);

  // int64 timestamp = 14;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 14;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 fee_limit = 18;
  void clear_fee_limit();
  static const int kFeeLimitFieldNumber = 18;
  ::google::protobuf::int64 fee_limit() const;
  void set_fee_limit(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Transaction.raw)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract > contract_;
  ::google::protobuf::internal::ArenaStringPtr ref_block_bytes_;
  ::google::protobuf::internal::ArenaStringPtr ref_block_hash_;
  ::google::protobuf::int64 ref_block_num_;
  ::google::protobuf::int64 expiration_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 fee_limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class Transaction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Transaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(nullptr);
  }

  Transaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Transaction_Contract Contract;
  typedef Transaction_raw raw;

  // accessors -------------------------------------------------------

  // .protocol.Transaction.raw raw_data = 1;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 1;
  const ::protocol::Transaction_raw& raw_data() const;
  ::protocol::Transaction_raw* release_raw_data();
  ::protocol::Transaction_raw* mutable_raw_data();
  void set_allocated_raw_data(::protocol::Transaction_raw* raw_data);

  // @@protoc_insertion_point(class_scope:protocol.Transaction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::protocol::Transaction_raw* raw_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader_raw final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockHeader.raw) */ {
 public:
  BlockHeader_raw();
  virtual ~BlockHeader_raw();

  BlockHeader_raw(const BlockHeader_raw& from);

  inline BlockHeader_raw& operator=(const BlockHeader_raw& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockHeader_raw(BlockHeader_raw&& from) noexcept
    : BlockHeader_raw() {
    *this = ::std::move(from);
  }

  inline BlockHeader_raw& operator=(BlockHeader_raw&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BlockHeader_raw& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockHeader_raw* internal_default_instance() {
    return reinterpret_cast<const BlockHeader_raw*>(
               &_BlockHeader_raw_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BlockHeader_raw* other);
  friend void swap(BlockHeader_raw& a, BlockHeader_raw& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader_raw* New() const final {
    return CreateMaybeMessage<BlockHeader_raw>(nullptr);
  }

  BlockHeader_raw* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeader_raw>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockHeader_raw& from);
  void MergeFrom(const BlockHeader_raw& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader_raw* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes tx_trie_root = 2;
  void clear_tx_trie_root();
  static const int kTxTrieRootFieldNumber = 2;
  const ::std::string& tx_trie_root() const;
  void set_tx_trie_root(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_trie_root(::std::string&& value);
  #endif
  void set_tx_trie_root(const char* value);
  void set_tx_trie_root(const void* value, size_t size);
  ::std::string* mutable_tx_trie_root();
  ::std::string* release_tx_trie_root();
  void set_allocated_tx_trie_root(::std::string* tx_trie_root);

  // bytes parent_hash = 3;
  void clear_parent_hash();
  static const int kParentHashFieldNumber = 3;
  const ::std::string& parent_hash() const;
  void set_parent_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_hash(::std::string&& value);
  #endif
  void set_parent_hash(const char* value);
  void set_parent_hash(const void* value, size_t size);
  ::std::string* mutable_parent_hash();
  ::std::string* release_parent_hash();
  void set_allocated_parent_hash(::std::string* parent_hash);

  // bytes witness_address = 9;
  void clear_witness_address();
  static const int kWitnessAddressFieldNumber = 9;
  const ::std::string& witness_address() const;
  void set_witness_address(const ::std::string& value);
  #if LANG_CXX11
  void set_witness_address(::std::string&& value);
  #endif
  void set_witness_address(const char* value);
  void set_witness_address(const void* value, size_t size);
  ::std::string* mutable_witness_address();
  ::std::string* release_witness_address();
  void set_allocated_witness_address(::std::string* witness_address);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 number = 7;
  void clear_number();
  static const int kNumberFieldNumber = 7;
  ::google::protobuf::int64 number() const;
  void set_number(::google::protobuf::int64 value);

  // int64 witness_id = 8;
  void clear_witness_id();
  static const int kWitnessIdFieldNumber = 8;
  ::google::protobuf::int64 witness_id() const;
  void set_witness_id(::google::protobuf::int64 value);

  // int32 version = 10;
  void clear_version();
  static const int kVersionFieldNumber = 10;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.BlockHeader.raw)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tx_trie_root_;
  ::google::protobuf::internal::ArenaStringPtr parent_hash_;
  ::google::protobuf::internal::ArenaStringPtr witness_address_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 number_;
  ::google::protobuf::int64 witness_id_;
  ::google::protobuf::int32 version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BlockHeader) */ {
 public:
  BlockHeader();
  virtual ~BlockHeader();

  BlockHeader(const BlockHeader& from);

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BlockHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(BlockHeader* other);
  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader* New() const final {
    return CreateMaybeMessage<BlockHeader>(nullptr);
  }

  BlockHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BlockHeader& from);
  void MergeFrom(const BlockHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BlockHeader_raw raw;

  // accessors -------------------------------------------------------

  // bytes witness_signature = 2;
  void clear_witness_signature();
  static const int kWitnessSignatureFieldNumber = 2;
  const ::std::string& witness_signature() const;
  void set_witness_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_witness_signature(::std::string&& value);
  #endif
  void set_witness_signature(const char* value);
  void set_witness_signature(const void* value, size_t size);
  ::std::string* mutable_witness_signature();
  ::std::string* release_witness_signature();
  void set_allocated_witness_signature(::std::string* witness_signature);

  // .protocol.BlockHeader.raw raw_data = 1;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 1;
  const ::protocol::BlockHeader_raw& raw_data() const;
  ::protocol::BlockHeader_raw* release_raw_data();
  ::protocol::BlockHeader_raw* mutable_raw_data();
  void set_allocated_raw_data(::protocol::BlockHeader_raw* raw_data);

  // @@protoc_insertion_point(class_scope:protocol.BlockHeader)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr witness_signature_;
  ::protocol::BlockHeader_raw* raw_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class TransferContract final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransferContract) */ {
 public:
  TransferContract();
  virtual ~TransferContract();

  TransferContract(const TransferContract& from);

  inline TransferContract& operator=(const TransferContract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferContract(TransferContract&& from) noexcept
    : TransferContract() {
    *this = ::std::move(from);
  }

  inline TransferContract& operator=(TransferContract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TransferContract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferContract* internal_default_instance() {
    return reinterpret_cast<const TransferContract*>(
               &_TransferContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TransferContract* other);
  friend void swap(TransferContract& a, TransferContract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferContract* New() const final {
    return CreateMaybeMessage<TransferContract>(nullptr);
  }

  TransferContract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferContract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransferContract& from);
  void MergeFrom(const TransferContract& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferContract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes owner_address = 1;
  void clear_owner_address();
  static const int kOwnerAddressFieldNumber = 1;
  const ::std::string& owner_address() const;
  void set_owner_address(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_address(::std::string&& value);
  #endif
  void set_owner_address(const char* value);
  void set_owner_address(const void* value, size_t size);
  ::std::string* mutable_owner_address();
  ::std::string* release_owner_address();
  void set_allocated_owner_address(::std::string* owner_address);

  // bytes to_address = 2;
  void clear_to_address();
  static const int kToAddressFieldNumber = 2;
  const ::std::string& to_address() const;
  void set_to_address(const ::std::string& value);
  #if LANG_CXX11
  void set_to_address(::std::string&& value);
  #endif
  void set_to_address(const char* value);
  void set_to_address(const void* value, size_t size);
  ::std::string* mutable_to_address();
  ::std::string* release_to_address();
  void set_allocated_to_address(::std::string* to_address);

  // int64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TransferContract)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr owner_address_;
  ::google::protobuf::internal::ArenaStringPtr to_address_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// -------------------------------------------------------------------

class TransferAssetContract final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransferAssetContract) */ {
 public:
  TransferAssetContract();
  virtual ~TransferAssetContract();

  TransferAssetContract(const TransferAssetContract& from);

  inline TransferAssetContract& operator=(const TransferAssetContract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransferAssetContract(TransferAssetContract&& from) noexcept
    : TransferAssetContract() {
    *this = ::std::move(from);
  }

  inline TransferAssetContract& operator=(TransferAssetContract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TransferAssetContract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransferAssetContract* internal_default_instance() {
    return reinterpret_cast<const TransferAssetContract*>(
               &_TransferAssetContract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TransferAssetContract* other);
  friend void swap(TransferAssetContract& a, TransferAssetContract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransferAssetContract* New() const final {
    return CreateMaybeMessage<TransferAssetContract>(nullptr);
  }

  TransferAssetContract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransferAssetContract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransferAssetContract& from);
  void MergeFrom(const TransferAssetContract& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferAssetContract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes asset_name = 1;
  void clear_asset_name();
  static const int kAssetNameFieldNumber = 1;
  const ::std::string& asset_name() const;
  void set_asset_name(const ::std::string& value);
  #if LANG_CXX11
  void set_asset_name(::std::string&& value);
  #endif
  void set_asset_name(const char* value);
  void set_asset_name(const void* value, size_t size);
  ::std::string* mutable_asset_name();
  ::std::string* release_asset_name();
  void set_allocated_asset_name(::std::string* asset_name);

  // bytes owner_address = 2;
  void clear_owner_address();
  static const int kOwnerAddressFieldNumber = 2;
  const ::std::string& owner_address() const;
  void set_owner_address(const ::std::string& value);
  #if LANG_CXX11
  void set_owner_address(::std::string&& value);
  #endif
  void set_owner_address(const char* value);
  void set_owner_address(const void* value, size_t size);
  ::std::string* mutable_owner_address();
  ::std::string* release_owner_address();
  void set_allocated_owner_address(::std::string* owner_address);

  // bytes to_address = 3;
  void clear_to_address();
  static const int kToAddressFieldNumber = 3;
  const ::std::string& to_address() const;
  void set_to_address(const ::std::string& value);
  #if LANG_CXX11
  void set_to_address(::std::string&& value);
  #endif
  void set_to_address(const char* value);
  void set_to_address(const void* value, size_t size);
  ::std::string* mutable_to_address();
  ::std::string* release_to_address();
  void set_allocated_to_address(::std::string* to_address);

  // int64 amount = 4;
  void clear_amount();
  static const int kAmountFieldNumber = 4;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TransferAssetContract)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asset_name_;
  ::google::protobuf::internal::ArenaStringPtr owner_address_;
  ::google::protobuf::internal::ArenaStringPtr to_address_;
  ::google::protobuf::int64 amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_TronInternal_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Transaction_Contract

// .protocol.Transaction.Contract.ContractType type = 1;
inline void Transaction_Contract::clear_type() {
  type_ = 0;
}
inline ::protocol::Transaction_Contract_ContractType Transaction_Contract::type() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.type)
  return static_cast< ::protocol::Transaction_Contract_ContractType >(type_);
}
inline void Transaction_Contract::set_type(::protocol::Transaction_Contract_ContractType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.type)
}

// .google.protobuf.Any parameter = 2;
inline bool Transaction_Contract::has_parameter() const {
  return this != internal_default_instance() && parameter_ != nullptr;
}
inline const ::google::protobuf::Any& Transaction_Contract::parameter() const {
  const ::google::protobuf::Any* p = parameter_;
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.parameter)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* Transaction_Contract::release_parameter() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.parameter)
  
  ::google::protobuf::Any* temp = parameter_;
  parameter_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* Transaction_Contract::mutable_parameter() {
  
  if (parameter_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    parameter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.parameter)
  return parameter_;
}
inline void Transaction_Contract::set_allocated_parameter(::google::protobuf::Any* parameter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(parameter_);
  }
  if (parameter) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      parameter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parameter, submessage_arena);
    }
    
  } else {
    
  }
  parameter_ = parameter;
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.parameter)
}

// bytes provider = 3;
inline void Transaction_Contract::clear_provider() {
  provider_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_Contract::provider() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.Contract.provider)
  return provider_.GetNoArena();
}
inline void Transaction_Contract::set_provider(const ::std::string& value) {
  
  provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.Contract.provider)
}
#if LANG_CXX11
inline void Transaction_Contract::set_provider(::std::string&& value) {
  
  provider_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.Contract.provider)
}
#endif
inline void Transaction_Contract::set_provider(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.Contract.provider)
}
inline void Transaction_Contract::set_provider(const void* value, size_t size) {
  
  provider_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.Contract.provider)
}
inline ::std::string* Transaction_Contract::mutable_provider() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.Contract.provider)
  return provider_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_Contract::release_provider() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.Contract.provider)
  
  return provider_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_Contract::set_allocated_provider(::std::string* provider) {
  if (provider != nullptr) {
    
  } else {
    
  }
  provider_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), provider);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.Contract.provider)
}

// -------------------------------------------------------------------

// Transaction_raw

// bytes ref_block_bytes = 1;
inline void Transaction_raw::clear_ref_block_bytes() {
  ref_block_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_raw::ref_block_bytes() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_bytes)
  return ref_block_bytes_.GetNoArena();
}
inline void Transaction_raw::set_ref_block_bytes(const ::std::string& value) {
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_bytes)
}
#if LANG_CXX11
inline void Transaction_raw::set_ref_block_bytes(::std::string&& value) {
  
  ref_block_bytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.raw.ref_block_bytes)
}
#endif
inline void Transaction_raw::set_ref_block_bytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.raw.ref_block_bytes)
}
inline void Transaction_raw::set_ref_block_bytes(const void* value, size_t size) {
  
  ref_block_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.raw.ref_block_bytes)
}
inline ::std::string* Transaction_raw::mutable_ref_block_bytes() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.ref_block_bytes)
  return ref_block_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_raw::release_ref_block_bytes() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.ref_block_bytes)
  
  return ref_block_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_raw::set_allocated_ref_block_bytes(::std::string* ref_block_bytes) {
  if (ref_block_bytes != nullptr) {
    
  } else {
    
  }
  ref_block_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_block_bytes);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.ref_block_bytes)
}

// int64 ref_block_num = 3;
inline void Transaction_raw::clear_ref_block_num() {
  ref_block_num_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::ref_block_num() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_num)
  return ref_block_num_;
}
inline void Transaction_raw::set_ref_block_num(::google::protobuf::int64 value) {
  
  ref_block_num_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_num)
}

// bytes ref_block_hash = 4;
inline void Transaction_raw::clear_ref_block_hash() {
  ref_block_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction_raw::ref_block_hash() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.ref_block_hash)
  return ref_block_hash_.GetNoArena();
}
inline void Transaction_raw::set_ref_block_hash(const ::std::string& value) {
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.ref_block_hash)
}
#if LANG_CXX11
inline void Transaction_raw::set_ref_block_hash(::std::string&& value) {
  
  ref_block_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.raw.ref_block_hash)
}
#endif
inline void Transaction_raw::set_ref_block_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.raw.ref_block_hash)
}
inline void Transaction_raw::set_ref_block_hash(const void* value, size_t size) {
  
  ref_block_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.raw.ref_block_hash)
}
inline ::std::string* Transaction_raw::mutable_ref_block_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.ref_block_hash)
  return ref_block_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction_raw::release_ref_block_hash() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw.ref_block_hash)
  
  return ref_block_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction_raw::set_allocated_ref_block_hash(::std::string* ref_block_hash) {
  if (ref_block_hash != nullptr) {
    
  } else {
    
  }
  ref_block_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ref_block_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw.ref_block_hash)
}

// int64 expiration = 8;
inline void Transaction_raw::clear_expiration() {
  expiration_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::expiration() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.expiration)
  return expiration_;
}
inline void Transaction_raw::set_expiration(::google::protobuf::int64 value) {
  
  expiration_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.expiration)
}

// repeated .protocol.Transaction.Contract contract = 11;
inline int Transaction_raw::contract_size() const {
  return contract_.size();
}
inline void Transaction_raw::clear_contract() {
  contract_.Clear();
}
inline ::protocol::Transaction_Contract* Transaction_raw::mutable_contract(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw.contract)
  return contract_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >*
Transaction_raw::mutable_contract() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.raw.contract)
  return &contract_;
}
inline const ::protocol::Transaction_Contract& Transaction_raw::contract(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.contract)
  return contract_.Get(index);
}
inline ::protocol::Transaction_Contract* Transaction_raw::add_contract() {
  // @@protoc_insertion_point(field_add:protocol.Transaction.raw.contract)
  return contract_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Transaction_Contract >&
Transaction_raw::contract() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.raw.contract)
  return contract_;
}

// int64 timestamp = 14;
inline void Transaction_raw::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.timestamp)
  return timestamp_;
}
inline void Transaction_raw::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.timestamp)
}

// int64 fee_limit = 18;
inline void Transaction_raw::clear_fee_limit() {
  fee_limit_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Transaction_raw::fee_limit() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw.fee_limit)
  return fee_limit_;
}
inline void Transaction_raw::set_fee_limit(::google::protobuf::int64 value) {
  
  fee_limit_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.raw.fee_limit)
}

// -------------------------------------------------------------------

// Transaction

// .protocol.Transaction.raw raw_data = 1;
inline bool Transaction::has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != nullptr;
}
inline void Transaction::clear_raw_data() {
  if (GetArenaNoVirtual() == nullptr && raw_data_ != nullptr) {
    delete raw_data_;
  }
  raw_data_ = nullptr;
}
inline const ::protocol::Transaction_raw& Transaction::raw_data() const {
  const ::protocol::Transaction_raw* p = raw_data_;
  // @@protoc_insertion_point(field_get:protocol.Transaction.raw_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::Transaction_raw*>(
      &::protocol::_Transaction_raw_default_instance_);
}
inline ::protocol::Transaction_raw* Transaction::release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.raw_data)
  
  ::protocol::Transaction_raw* temp = raw_data_;
  raw_data_ = nullptr;
  return temp;
}
inline ::protocol::Transaction_raw* Transaction::mutable_raw_data() {
  
  if (raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::Transaction_raw>(GetArenaNoVirtual());
    raw_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.raw_data)
  return raw_data_;
}
inline void Transaction::set_allocated_raw_data(::protocol::Transaction_raw* raw_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete raw_data_;
  }
  if (raw_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      raw_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.raw_data)
}

// -------------------------------------------------------------------

// BlockHeader_raw

// int64 timestamp = 1;
inline void BlockHeader_raw::clear_timestamp() {
  timestamp_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockHeader_raw::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.timestamp)
  return timestamp_;
}
inline void BlockHeader_raw::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.timestamp)
}

// bytes tx_trie_root = 2;
inline void BlockHeader_raw::clear_tx_trie_root() {
  tx_trie_root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader_raw::tx_trie_root() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.tx_trie_root)
  return tx_trie_root_.GetNoArena();
}
inline void BlockHeader_raw::set_tx_trie_root(const ::std::string& value) {
  
  tx_trie_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.tx_trie_root)
}
#if LANG_CXX11
inline void BlockHeader_raw::set_tx_trie_root(::std::string&& value) {
  
  tx_trie_root_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.raw.tx_trie_root)
}
#endif
inline void BlockHeader_raw::set_tx_trie_root(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tx_trie_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.raw.tx_trie_root)
}
inline void BlockHeader_raw::set_tx_trie_root(const void* value, size_t size) {
  
  tx_trie_root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.raw.tx_trie_root)
}
inline ::std::string* BlockHeader_raw::mutable_tx_trie_root() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.tx_trie_root)
  return tx_trie_root_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader_raw::release_tx_trie_root() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.tx_trie_root)
  
  return tx_trie_root_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader_raw::set_allocated_tx_trie_root(::std::string* tx_trie_root) {
  if (tx_trie_root != nullptr) {
    
  } else {
    
  }
  tx_trie_root_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_trie_root);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.tx_trie_root)
}

// bytes parent_hash = 3;
inline void BlockHeader_raw::clear_parent_hash() {
  parent_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader_raw::parent_hash() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.parent_hash)
  return parent_hash_.GetNoArena();
}
inline void BlockHeader_raw::set_parent_hash(const ::std::string& value) {
  
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.parent_hash)
}
#if LANG_CXX11
inline void BlockHeader_raw::set_parent_hash(::std::string&& value) {
  
  parent_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.raw.parent_hash)
}
#endif
inline void BlockHeader_raw::set_parent_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.raw.parent_hash)
}
inline void BlockHeader_raw::set_parent_hash(const void* value, size_t size) {
  
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.raw.parent_hash)
}
inline ::std::string* BlockHeader_raw::mutable_parent_hash() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.parent_hash)
  return parent_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader_raw::release_parent_hash() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.parent_hash)
  
  return parent_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader_raw::set_allocated_parent_hash(::std::string* parent_hash) {
  if (parent_hash != nullptr) {
    
  } else {
    
  }
  parent_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.parent_hash)
}

// int64 number = 7;
inline void BlockHeader_raw::clear_number() {
  number_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockHeader_raw::number() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.number)
  return number_;
}
inline void BlockHeader_raw::set_number(::google::protobuf::int64 value) {
  
  number_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.number)
}

// int64 witness_id = 8;
inline void BlockHeader_raw::clear_witness_id() {
  witness_id_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockHeader_raw::witness_id() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.witness_id)
  return witness_id_;
}
inline void BlockHeader_raw::set_witness_id(::google::protobuf::int64 value) {
  
  witness_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.witness_id)
}

// bytes witness_address = 9;
inline void BlockHeader_raw::clear_witness_address() {
  witness_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader_raw::witness_address() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.witness_address)
  return witness_address_.GetNoArena();
}
inline void BlockHeader_raw::set_witness_address(const ::std::string& value) {
  
  witness_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.witness_address)
}
#if LANG_CXX11
inline void BlockHeader_raw::set_witness_address(::std::string&& value) {
  
  witness_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.raw.witness_address)
}
#endif
inline void BlockHeader_raw::set_witness_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  witness_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.raw.witness_address)
}
inline void BlockHeader_raw::set_witness_address(const void* value, size_t size) {
  
  witness_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.raw.witness_address)
}
inline ::std::string* BlockHeader_raw::mutable_witness_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw.witness_address)
  return witness_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader_raw::release_witness_address() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw.witness_address)
  
  return witness_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader_raw::set_allocated_witness_address(::std::string* witness_address) {
  if (witness_address != nullptr) {
    
  } else {
    
  }
  witness_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), witness_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw.witness_address)
}

// int32 version = 10;
inline void BlockHeader_raw::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 BlockHeader_raw::version() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw.version)
  return version_;
}
inline void BlockHeader_raw::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.raw.version)
}

// -------------------------------------------------------------------

// BlockHeader

// .protocol.BlockHeader.raw raw_data = 1;
inline bool BlockHeader::has_raw_data() const {
  return this != internal_default_instance() && raw_data_ != nullptr;
}
inline void BlockHeader::clear_raw_data() {
  if (GetArenaNoVirtual() == nullptr && raw_data_ != nullptr) {
    delete raw_data_;
  }
  raw_data_ = nullptr;
}
inline const ::protocol::BlockHeader_raw& BlockHeader::raw_data() const {
  const ::protocol::BlockHeader_raw* p = raw_data_;
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.raw_data)
  return p != nullptr ? *p : *reinterpret_cast<const ::protocol::BlockHeader_raw*>(
      &::protocol::_BlockHeader_raw_default_instance_);
}
inline ::protocol::BlockHeader_raw* BlockHeader::release_raw_data() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.raw_data)
  
  ::protocol::BlockHeader_raw* temp = raw_data_;
  raw_data_ = nullptr;
  return temp;
}
inline ::protocol::BlockHeader_raw* BlockHeader::mutable_raw_data() {
  
  if (raw_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::protocol::BlockHeader_raw>(GetArenaNoVirtual());
    raw_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.raw_data)
  return raw_data_;
}
inline void BlockHeader::set_allocated_raw_data(::protocol::BlockHeader_raw* raw_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete raw_data_;
  }
  if (raw_data) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      raw_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, raw_data, submessage_arena);
    }
    
  } else {
    
  }
  raw_data_ = raw_data;
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.raw_data)
}

// bytes witness_signature = 2;
inline void BlockHeader::clear_witness_signature() {
  witness_signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockHeader::witness_signature() const {
  // @@protoc_insertion_point(field_get:protocol.BlockHeader.witness_signature)
  return witness_signature_.GetNoArena();
}
inline void BlockHeader::set_witness_signature(const ::std::string& value) {
  
  witness_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.BlockHeader.witness_signature)
}
#if LANG_CXX11
inline void BlockHeader::set_witness_signature(::std::string&& value) {
  
  witness_signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.BlockHeader.witness_signature)
}
#endif
inline void BlockHeader::set_witness_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  witness_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.BlockHeader.witness_signature)
}
inline void BlockHeader::set_witness_signature(const void* value, size_t size) {
  
  witness_signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.BlockHeader.witness_signature)
}
inline ::std::string* BlockHeader::mutable_witness_signature() {
  
  // @@protoc_insertion_point(field_mutable:protocol.BlockHeader.witness_signature)
  return witness_signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockHeader::release_witness_signature() {
  // @@protoc_insertion_point(field_release:protocol.BlockHeader.witness_signature)
  
  return witness_signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockHeader::set_allocated_witness_signature(::std::string* witness_signature) {
  if (witness_signature != nullptr) {
    
  } else {
    
  }
  witness_signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), witness_signature);
  // @@protoc_insertion_point(field_set_allocated:protocol.BlockHeader.witness_signature)
}

// -------------------------------------------------------------------

// TransferContract

// bytes owner_address = 1;
inline void TransferContract::clear_owner_address() {
  owner_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferContract.owner_address)
  return owner_address_.GetNoArena();
}
inline void TransferContract::set_owner_address(const ::std::string& value) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransferContract.owner_address)
}
#if LANG_CXX11
inline void TransferContract::set_owner_address(::std::string&& value) {
  
  owner_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransferContract.owner_address)
}
#endif
inline void TransferContract::set_owner_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransferContract.owner_address)
}
inline void TransferContract::set_owner_address(const void* value, size_t size) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransferContract.owner_address)
}
inline ::std::string* TransferContract::mutable_owner_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransferContract.owner_address)
  return owner_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferContract.owner_address)
  
  return owner_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferContract::set_allocated_owner_address(::std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferContract.owner_address)
}

// bytes to_address = 2;
inline void TransferContract::clear_to_address() {
  to_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferContract::to_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferContract.to_address)
  return to_address_.GetNoArena();
}
inline void TransferContract::set_to_address(const ::std::string& value) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransferContract.to_address)
}
#if LANG_CXX11
inline void TransferContract::set_to_address(::std::string&& value) {
  
  to_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransferContract.to_address)
}
#endif
inline void TransferContract::set_to_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransferContract.to_address)
}
inline void TransferContract::set_to_address(const void* value, size_t size) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransferContract.to_address)
}
inline ::std::string* TransferContract::mutable_to_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransferContract.to_address)
  return to_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferContract::release_to_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferContract.to_address)
  
  return to_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferContract::set_allocated_to_address(::std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  to_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferContract.to_address)
}

// int64 amount = 3;
inline void TransferContract::clear_amount() {
  amount_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 TransferContract::amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransferContract.amount)
  return amount_;
}
inline void TransferContract::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransferContract.amount)
}

// -------------------------------------------------------------------

// TransferAssetContract

// bytes asset_name = 1;
inline void TransferAssetContract::clear_asset_name() {
  asset_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAssetContract::asset_name() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.asset_name)
  return asset_name_.GetNoArena();
}
inline void TransferAssetContract::set_asset_name(const ::std::string& value) {
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.asset_name)
}
#if LANG_CXX11
inline void TransferAssetContract::set_asset_name(::std::string&& value) {
  
  asset_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransferAssetContract.asset_name)
}
#endif
inline void TransferAssetContract::set_asset_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransferAssetContract.asset_name)
}
inline void TransferAssetContract::set_asset_name(const void* value, size_t size) {
  
  asset_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransferAssetContract.asset_name)
}
inline ::std::string* TransferAssetContract::mutable_asset_name() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransferAssetContract.asset_name)
  return asset_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAssetContract::release_asset_name() {
  // @@protoc_insertion_point(field_release:protocol.TransferAssetContract.asset_name)
  
  return asset_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAssetContract::set_allocated_asset_name(::std::string* asset_name) {
  if (asset_name != nullptr) {
    
  } else {
    
  }
  asset_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asset_name);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferAssetContract.asset_name)
}

// bytes owner_address = 2;
inline void TransferAssetContract::clear_owner_address() {
  owner_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAssetContract::owner_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.owner_address)
  return owner_address_.GetNoArena();
}
inline void TransferAssetContract::set_owner_address(const ::std::string& value) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.owner_address)
}
#if LANG_CXX11
inline void TransferAssetContract::set_owner_address(::std::string&& value) {
  
  owner_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransferAssetContract.owner_address)
}
#endif
inline void TransferAssetContract::set_owner_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransferAssetContract.owner_address)
}
inline void TransferAssetContract::set_owner_address(const void* value, size_t size) {
  
  owner_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransferAssetContract.owner_address)
}
inline ::std::string* TransferAssetContract::mutable_owner_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransferAssetContract.owner_address)
  return owner_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAssetContract::release_owner_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferAssetContract.owner_address)
  
  return owner_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAssetContract::set_allocated_owner_address(::std::string* owner_address) {
  if (owner_address != nullptr) {
    
  } else {
    
  }
  owner_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), owner_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferAssetContract.owner_address)
}

// bytes to_address = 3;
inline void TransferAssetContract::clear_to_address() {
  to_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TransferAssetContract::to_address() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.to_address)
  return to_address_.GetNoArena();
}
inline void TransferAssetContract::set_to_address(const ::std::string& value) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.to_address)
}
#if LANG_CXX11
inline void TransferAssetContract::set_to_address(::std::string&& value) {
  
  to_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransferAssetContract.to_address)
}
#endif
inline void TransferAssetContract::set_to_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransferAssetContract.to_address)
}
inline void TransferAssetContract::set_to_address(const void* value, size_t size) {
  
  to_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransferAssetContract.to_address)
}
inline ::std::string* TransferAssetContract::mutable_to_address() {
  
  // @@protoc_insertion_point(field_mutable:protocol.TransferAssetContract.to_address)
  return to_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransferAssetContract::release_to_address() {
  // @@protoc_insertion_point(field_release:protocol.TransferAssetContract.to_address)
  
  return to_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransferAssetContract::set_allocated_to_address(::std::string* to_address) {
  if (to_address != nullptr) {
    
  } else {
    
  }
  to_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransferAssetContract.to_address)
}

// int64 amount = 4;
inline void TransferAssetContract::clear_amount() {
  amount_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 TransferAssetContract::amount() const {
  // @@protoc_insertion_point(field_get:protocol.TransferAssetContract.amount)
  return amount_;
}
inline void TransferAssetContract::set_amount(::google::protobuf::int64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransferAssetContract.amount)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::Transaction_Contract_ContractType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Contract_ContractType>() {
  return ::protocol::Transaction_Contract_ContractType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_TronInternal_2eproto
